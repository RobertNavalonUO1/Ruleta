<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/api/ruletaeuropea/Pantallas/PantallaRuletaGirando.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/api/ruletaeuropea/Pantallas/PantallaRuletaGirando.kt" />
              <option name="originalContent" value="package com.api.ruletaeuropea.pantallas&#10;&#10;import com.api.ruletaeuropea.App&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import com.api.ruletaeuropea.Modelo.Apuesta&#10;import com.api.ruletaeuropea.R&#10;import com.api.ruletaeuropea.componentes.CoinsDisplay&#10;import com.api.ruletaeuropea.data.entity.Jugador&#10;import com.api.ruletaeuropea.logica.calcularPago&#10;import com.api.ruletaeuropea.logica.evaluarApuesta&#10;import com.api.ruletaeuropea.logica.tipoApuesta&#10;import com.api.ruletaeuropea.logica.construirApuestaCompleta&#10;import kotlinx.coroutines.delay&#10;import com.airbnb.lottie.compose.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import com.api.ruletaeuropea.data.entity.Ruleta&#10;import com.api.ruletaeuropea.data.entity.Historial&#10;&#10;@Composable&#10;fun PantallaRuletaGirando(&#10;    navController: NavController,&#10;    jugador: Jugador,&#10;    apuestas: MutableState&lt;List&lt;Apuesta&gt;&gt;,&#10;    onActualizarSaldo: (Int) -&gt; Unit&#10;) {&#10;    var resultado by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var mostrarResultado by remember { mutableStateOf(false) }&#10;&#10;    // Simula el giro de la ruleta&#10;    LaunchedEffect(Unit) {&#10;        delay(1500) // tiempo de giro&#10;        resultado = (0..36).random()&#10;        delay(2000) // tiempo antes de mostrar resultado&#10;        mostrarResultado = true&#10;    }&#10;&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;&#10;        // Fondo visual&#10;        Image(&#10;            painter = painterResource(id = R.drawable.fondo),&#10;            contentDescription = null,&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = androidx.compose.ui.layout.ContentScale.Crop&#10;        )&#10;        CoinsDisplay(&#10;            cantidad = jugador.NumMonedas,&#10;            modifier = Modifier&#10;                .align(Alignment.TopStart)&#10;                .padding(16.dp)&#10;        )&#10;&#10;        if (resultado == null || !mostrarResultado) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(26.dp),&#10;                horizontalArrangement = Arrangement.SpaceEvenly,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Imagen de ruleta girando&#10;                val composition by rememberLottieComposition(LottieCompositionSpec.Asset(&quot;ruleta_animada.json&quot;))&#10;                val progress by animateLottieCompositionAsState(&#10;                    composition = composition,&#10;                    iterations = LottieConstants.IterateForever&#10;                )&#10;&#10;                LottieAnimation(&#10;                    composition = composition,&#10;                    progress = progress,&#10;                    modifier = Modifier.size(600.dp)&#10;                )&#10;&#10;&#10;                // Panel de resumen de apuesta&#10;                Column(&#10;                    modifier = Modifier&#10;                        .background(Color.Gray.copy(alpha = 0.6f), shape = RoundedCornerShape(12.dp))&#10;                        .padding(26.dp)&#10;                        .width(500.dp),&#10;                    horizontalAlignment = Alignment.Start&#10;                ) {&#10;                    Text(&quot;YOUR BET:&quot;, fontSize = 20.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    apuestas.value.forEach {&#10;                        Text(&#10;                            text = &quot;${tipoApuesta(it.numero)}: ${it.valorMoneda}&quot;,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFFFFA500) // naranja suave&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    val total = apuestas.value.sumOf { it.valorMoneda }&#10;                    Text(&quot;TOTAL: $total C&quot;, fontSize = 18.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;                }&#10;            }&#10;        }&#10;        else {&#10;            Image(&#10;                painter = painterResource(id = R.drawable.fondo_1),&#10;                contentDescription = null,&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentScale = androidx.compose.ui.layout.ContentScale.Crop&#10;            )&#10;            val apuestasGanadoras = apuestas.value.filter { evaluarApuesta(it, resultado!!) }&#10;            val pagoTotal = calcularPago(apuestas.value, resultado!!)&#10;&#10;            // Actualiza el saldo del jugador&#10;            LaunchedEffect(pagoTotal) {&#10;                val nuevoSaldo = jugador.NumMonedas + pagoTotal&#10;&#10;                // Actualiza la variable de estado&#10;                onActualizarSaldo(pagoTotal)&#10;&#10;                val daoRuleta = App.database.ruletaDao()&#10;                val daoApuesta = App.database.apuestaDao()&#10;                val daoJugador = App.database.jugadorDao()&#10;                val daoHistorial = App.database.historialDao()&#10;&#10;                //Inserta el resultado de la ruleta&#10;                val idRuleta = withContext(Dispatchers.IO) {&#10;                    daoRuleta.insertar(Ruleta(NumeroGanador = resultado!!))&#10;                }&#10;&#10;                // Actualiza el saldo del jugador en la base de datos&#10;                withContext(Dispatchers.IO) {&#10;                    val jugadorActualizado = jugador.copy(NumMonedas = nuevoSaldo)&#10;                    daoJugador.actualizar(jugadorActualizado)&#10;                }&#10;&#10;                // Guarda la apuesta en el historial&#10;                withContext(Dispatchers.IO) {&#10;                    apuestas.value.forEach { apuesta -&gt;&#10;                        // Inserta la apuesta y obtiene su ID&#10;                        val apuestaCompleta = construirApuestaCompleta(apuesta, jugador, resultado!!, idRuleta)&#10;                        val idApuesta = daoApuesta.insertar(apuestaCompleta) // solo aquí se inserta&#10;&#10;                        // Inserta el registro en historial usando el ID de la apuesta&#10;                        val registroHistorial = Historial(&#10;                            NombreJugador = jugador.NombreJugador,&#10;                            NumApuesta = idApuesta,&#10;                            Resultado = resultado.toString(),&#10;                            SaldoDespues = nuevoSaldo&#10;                        )&#10;                        daoHistorial.insertar(registroHistorial)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // Número ganador con fondo de color&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .background(&#10;                            color = when (resultado) {&#10;                                0 -&gt; Color.Green&#10;                                in listOf(1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36) -&gt; Color.Red&#10;                                else -&gt; Color.Black&#10;                            },&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        ),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;$resultado&quot;,&#10;                        fontSize = 64.sp, // más grande&#10;                        fontWeight = FontWeight.ExtraBold,&#10;                        color = Color(0xFFFFD700) // dorado&#10;                    )&#10;&#10;                }&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                // Panel de resultados&#10;                Column(&#10;                    modifier = Modifier&#10;                        .background(Color.Gray.copy(alpha = 0.8f), shape = RoundedCornerShape(12.dp))&#10;                        .padding(16.dp)&#10;                        .width(400.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    if (pagoTotal &gt; 0) {&#10;                        Text(&#10;                            text = &quot;YOU WON&quot;,&#10;                            fontSize = 60.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color(0xFFFFD700)&#10;                        )&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;YOU LOSE&quot;,&#10;                            fontSize = 60.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.LightGray&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    apuestasGanadoras.forEach {&#10;                        Text(&#10;                            text = &quot;${tipoApuesta(it.numero)}: ${it.valorMoneda}&quot;,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFFFFD700)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&quot;TOTAL: $pagoTotal C&quot;, fontSize = 18.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;                }&#10;&#10;                // Botones&#10;                Row(&#10;                    horizontalArrangement = Arrangement.SpaceEvenly,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.play_again),&#10;                        contentDescription = &quot;Jugar de nuevo&quot;,&#10;                        modifier = Modifier&#10;                            .size(200.dp)&#10;                            .clickable {&#10;                                apuestas.value = emptyList()&#10;                                navController.popBackStack()&#10;                            }&#10;                    )&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.exit),&#10;                        contentDescription = &quot;Salir&quot;,&#10;                        modifier = Modifier&#10;                            .size(200.dp)&#10;                            .clickable {&#10;                                // Limpia las apuestas y vuelve al menú principal&#10;                                apuestas.value = emptyList()&#10;                                navController.navigate(&quot;menu&quot;) {&#10;                                    popUpTo(&quot;menu&quot;) { inclusive = true } // limpia el historial&#10;                                    launchSingleTop = true // evita duplicar pantallas&#10;                                }&#10;                            }&#10;                    )&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.api.ruletaeuropea.pantallas&#10;&#10;import com.api.ruletaeuropea.App&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Divider&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.drawWithCache&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.semantics.contentDescription&#10;import androidx.compose.ui.semantics.semantics&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import com.api.ruletaeuropea.Modelo.Apuesta&#10;import com.api.ruletaeuropea.R&#10;import com.api.ruletaeuropea.componentes.CoinsDisplay&#10;import com.api.ruletaeuropea.data.entity.Jugador&#10;import com.api.ruletaeuropea.logica.calcularPago&#10;import com.api.ruletaeuropea.logica.evaluarApuesta&#10;import com.api.ruletaeuropea.logica.tipoApuesta&#10;import com.api.ruletaeuropea.logica.construirApuestaCompleta&#10;import kotlinx.coroutines.delay&#10;import com.airbnb.lottie.compose.*&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import com.api.ruletaeuropea.data.entity.Ruleta&#10;import com.api.ruletaeuropea.data.entity.Historial&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.systemBarsPadding&#10;&#10;// Colores y tamaños comunes (evitar magic numbers)&#10;private val Gold = Color(0xFFFFD700)&#10;private val GlassBg = Color(0x661A1A1A) // ~40% alpha&#10;private val CardShape = RoundedCornerShape(16.dp)&#10;private val PillShape = RoundedCornerShape(28.dp)&#10;private val RedNumbers: Set&lt;Int&gt; = setOf(1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36)&#10;&#10;/**&#10; * Pantalla de giro de la ruleta con animación y resultado.&#10; * Mantiene la firma pública, lógica y flujo de navegación existentes.&#10; */&#10;@Composable&#10;fun PantallaRuletaGirando(&#10;    navController: NavController,&#10;    jugador: Jugador,&#10;    apuestas: MutableState&lt;List&lt;Apuesta&gt;&gt;,&#10;    onActualizarSaldo: (Int) -&gt; Unit&#10;) {&#10;    var resultado by rememberSaveable { mutableStateOf&lt;Int?&gt;(null) }&#10;    var mostrarResultado by rememberSaveable { mutableStateOf(false) }&#10;&#10;    // Simula el giro de la ruleta y el paso a mostrar resultado&#10;    LaunchedEffect(Unit) {&#10;        delay(1500) // tiempo de giro&#10;        resultado = (0..36).random()&#10;        delay(2000) // tiempo antes de mostrar resultado&#10;        mostrarResultado = true&#10;    }&#10;&#10;    // Reemplazado por Box porque no usamos maxWidth/maxHeight aquí&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .systemBarsPadding()&#10;    ) {&#10;        // Fondo según estado&#10;        val fondoResId = if (mostrarResultado) R.drawable.fondo_1 else R.drawable.fondo&#10;        Image(&#10;            painter = painterResource(id = fondoResId),&#10;            contentDescription = null, // decorativo&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = androidx.compose.ui.layout.ContentScale.Crop&#10;        )&#10;&#10;        // Overlay radial optimizado con drawWithCache: se recalcula solo si cambia size&#10;        Box(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .drawWithCache {&#10;                    val center = Offset(size.width / 2f, size.height / 2f)&#10;                    val radius = size.minDimension * 0.9f&#10;                    val brush = Brush.radialGradient(&#10;                        colors = listOf(Color.Transparent, Color.Black.copy(alpha = 0.55f)),&#10;                        center = center,&#10;                        radius = radius&#10;                    )&#10;                    onDrawBehind { drawRect(brush = brush) }&#10;                }&#10;        )&#10;&#10;        // Monedas arriba a la izquierda&#10;        CoinsDisplay(&#10;            cantidad = jugador.NumMonedas,&#10;            modifier = Modifier&#10;                .align(Alignment.TopStart)&#10;                .padding(16.dp)&#10;        )&#10;&#10;        // Contenido con transición&#10;        Crossfade(targetState = mostrarResultado, animationSpec = tween(durationMillis = 500)) { showResult -&gt;&#10;            if (!showResult) {&#10;                GirandoSection(&#10;                    apuestas = apuestas.value&#10;                )&#10;            } else {&#10;                // Solo mostramos resultado si ya se generó el número&#10;                resultado?.let { numeroGanador -&gt;&#10;                    ResultadoSection(&#10;                        navController = navController,&#10;                        jugador = jugador,&#10;                        apuestas = apuestas,&#10;                        resultado = numeroGanador,&#10;                        onActualizarSaldo = onActualizarSaldo&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Sección visible mientras la ruleta está girando: animación + resumen de apuesta.&#10; */&#10;@Composable&#10;private fun GirandoSection(&#10;    apuestas: List&lt;Apuesta&gt;&#10;) {&#10;    BoxWithConstraints(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp)&#10;    ) {&#10;        // Guardar valores de constraints antes de entrar al RowScope&#10;        val boxMaxWidth = maxWidth&#10;        val wheelSize = boxMaxWidth * 0.55f&#10;        val panelMinWidth = 280.dp&#10;        val panelWidth = maxOf(panelMinWidth, boxMaxWidth - wheelSize - 32.dp)&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalArrangement = Arrangement.SpaceEvenly,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Animación de ruleta girando&#10;            val composition by rememberLottieComposition(LottieCompositionSpec.Asset(&quot;ruleta_animada.json&quot;))&#10;            val progress by animateLottieCompositionAsState(&#10;                composition = composition,&#10;                iterations = LottieConstants.IterateForever&#10;            )&#10;&#10;            LottieAnimation(&#10;                composition = composition,&#10;                progress = progress,&#10;                modifier = Modifier&#10;                    .size(wheelSize)&#10;                    .semantics { contentDescription = &quot;Ruleta girando&quot; } // TODO(i18n)&#10;            )&#10;&#10;            // Tarjeta de resumen de apuesta&#10;            BetSummaryCard(&#10;                apuestas = apuestas,&#10;                modifier = Modifier.width(panelWidth)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Tarjeta estilo &quot;glass&quot; con el resumen de apuestas y total.&#10; */&#10;@Composable&#10;private fun BetSummaryCard(&#10;    apuestas: List&lt;Apuesta&gt; = emptyList(),&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val total = remember(apuestas) { apuestas.sumOf { it.valorMoneda } }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .clip(CardShape)&#10;            .background(GlassBg)&#10;            .border(width = 1.dp, color = Color.White.copy(alpha = 0.08f), shape = CardShape)&#10;            .padding(20.dp)&#10;            .semantics { contentDescription = &quot;Resumen de apuesta&quot; } // TODO(i18n)&#10;    ) {&#10;        Text(&#10;            text = &quot;YOUR BET:&quot;, // TODO(i18n)&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.White&#10;        )&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        if (apuestas.isEmpty()) {&#10;            Text(&#10;                text = &quot;No bets placed&quot;, // TODO(i18n)&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFA500)&#10;            )&#10;        } else {&#10;            apuestas.forEachIndexed { index, it -&gt;&#10;                Text(&#10;                    text = &quot;${tipoApuesta(it.numero)}: ${it.valorMoneda}&quot;,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFFFA500)&#10;                )&#10;                if (index != apuestas.lastIndex) {&#10;                    Divider(modifier = Modifier.padding(vertical = 6.dp), color = Color.White.copy(alpha = 0.1f))&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Text(&#10;            text = &quot;TOTAL: $total C&quot;, // TODO(i18n)&#10;            fontSize = 18.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.White&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Sección con el resultado: badge del número ganador, detalle y acciones.&#10; * Ejecuta las escrituras a Room una única vez por número de resultado.&#10; */&#10;@Composable&#10;private fun ResultadoSection(&#10;    navController: NavController,&#10;    jugador: Jugador,&#10;    apuestas: MutableState&lt;List&lt;Apuesta&gt;&gt;,&#10;    resultado: Int,&#10;    onActualizarSaldo: (Int) -&gt; Unit&#10;) {&#10;    // Calcular ganadoras y pago total (recordado por resultado y apuestas)&#10;    val apuestasGanadoras = remember(resultado, apuestas.value) { apuestas.value.filter { evaluarApuesta(it, resultado) } }&#10;    val pagoTotal = remember(resultado, apuestas.value) { calcularPago(apuestas.value, resultado) }&#10;&#10;    // Guardar que ya persistimos este resultado (sobrevive rotación)&#10;    var lastPersistedResult by rememberSaveable { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    // Escrituras a DB una única vez por resultado (clave: resultado)&#10;    LaunchedEffect(resultado) {&#10;        if (lastPersistedResult == resultado) return@LaunchedEffect&#10;&#10;        val pago = pagoTotal&#10;        val nuevoSaldo = jugador.NumMonedas + pago&#10;&#10;        withContext(Dispatchers.IO) {&#10;            val daoRuleta = App.database.ruletaDao()&#10;            val daoApuesta = App.database.apuestaDao()&#10;            val daoJugador = App.database.jugadorDao()&#10;            val daoHistorial = App.database.historialDao()&#10;&#10;            // Inserta el resultado de la ruleta y obtiene ID&#10;            val idRuleta = daoRuleta.insertar(Ruleta(NumeroGanador = resultado))&#10;&#10;            // Actualiza saldo del jugador en BD&#10;            val jugadorActualizado = jugador.copy(NumMonedas = nuevoSaldo)&#10;            daoJugador.actualizar(jugadorActualizado)&#10;&#10;            // Guarda cada apuesta y su registro de historial&#10;            apuestas.value.forEach { apuesta -&gt;&#10;                val apuestaCompleta = construirApuestaCompleta(apuesta, jugador, resultado, idRuleta)&#10;                val idApuesta = daoApuesta.insertar(apuestaCompleta)&#10;                val registroHistorial = Historial(&#10;                    NombreJugador = jugador.NombreJugador,&#10;                    NumApuesta = idApuesta,&#10;                    Resultado = resultado.toString(),&#10;                    SaldoDespues = nuevoSaldo&#10;                )&#10;                daoHistorial.insertar(registroHistorial)&#10;            }&#10;        }&#10;&#10;        // Actualiza estado en UI (una vez)&#10;        onActualizarSaldo(pago)&#10;        lastPersistedResult = resultado&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        ResultBadge(&#10;            numero = resultado,&#10;            modifier = Modifier&#10;                .size(120.dp)&#10;                .semantics { contentDescription = &quot;Resultado: $resultado&quot; } // TODO(i18n)&#10;        )&#10;&#10;        // Panel de resultados (glass card)&#10;        Column(&#10;            modifier = Modifier&#10;                .clip(CardShape)&#10;                .background(GlassBg.copy(alpha = 0.8f))&#10;                .border(width = 1.dp, color = Color.White.copy(alpha = 0.08f), shape = CardShape)&#10;                .padding(16.dp)&#10;                .widthIn(min = 280.dp, max = 420.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            if (pagoTotal &gt; 0) {&#10;                Text(&#10;                    text = &quot;YOU WON&quot;, // TODO(i18n)&#10;                    fontSize = 56.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Gold&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = &quot;YOU LOSE&quot;, // TODO(i18n)&#10;                    fontSize = 56.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFFD0D0D0)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            apuestasGanadoras.forEach { it -&gt;&#10;                Text(&#10;                    text = &quot;${tipoApuesta(it.numero)}: ${it.valorMoneda}&quot;,&#10;                    fontSize = 16.sp,&#10;                    color = Gold&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;TOTAL: $pagoTotal C&quot;, // TODO(i18n)&#10;                fontSize = 18.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White&#10;            )&#10;        }&#10;&#10;        ActionButtons(&#10;            onPlayAgain = {&#10;                apuestas.value = emptyList()&#10;                navController.popBackStack()&#10;            },&#10;            onExit = {&#10;                apuestas.value = emptyList()&#10;                navController.navigate(&quot;menu&quot;) {&#10;                    popUpTo(&quot;menu&quot;) { inclusive = true }&#10;                    launchSingleTop = true&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Muestra un badge redondeado con el número ganador y color contextual (rojo/negro/verde).&#10; */&#10;@Composable&#10;private fun ResultBadge(&#10;    numero: Int,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val bgColor = when (numero) {&#10;        0 -&gt; Color(0xFF1DB954) // verde más armónico en oscuro&#10;        in RedNumbers -&gt; Color.Red&#10;        else -&gt; Color.Black&#10;    }&#10;    Box(&#10;        modifier = modifier&#10;            .clip(RoundedCornerShape(16.dp))&#10;            .background(bgColor),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;$numero&quot;,&#10;            fontSize = 64.sp,&#10;            fontWeight = FontWeight.ExtraBold,&#10;            color = Gold&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Botones de acción: jugar de nuevo (primario dorado) y salir (outlined).&#10; */&#10;@Composable&#10;private fun ActionButtons(&#10;    onPlayAgain: () -&gt; Unit,&#10;    onExit: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 24.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Button(&#10;            onClick = onPlayAgain,&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .height(56.dp),&#10;            shape = PillShape,&#10;            colors = ButtonDefaults.buttonColors(containerColor = Gold, contentColor = Color.Black)&#10;        ) {&#10;            Text(text = &quot;Play again&quot;, fontWeight = FontWeight.SemiBold) // TODO(i18n)&#10;        }&#10;&#10;        OutlinedButton(&#10;            onClick = onExit,&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .height(56.dp),&#10;            shape = PillShape,&#10;            colors = ButtonDefaults.outlinedButtonColors(contentColor = Color.White),&#10;            border = androidx.compose.foundation.BorderStroke(1.dp, Color.White.copy(alpha = 0.5f))&#10;        ) {&#10;            Text(text = &quot;Exit&quot;, fontWeight = FontWeight.SemiBold) // TODO(i18n)&#10;        }&#10;    }&#10;}&#10;&#10;/*&#10;================ Manual Test Checklist (marcar al revisar PR) ================&#10;[ ] Inicio: se muestra animación ~1.5s + 2s, luego Crossfade suave al resultado.&#10;[ ] Sin apuestas: BetSummaryCard muestra &quot;No bets placed&quot; y TOTAL: 0 sin crash.&#10;[ ] Varias apuestas, algunas ganan: listado correcto, pagoTotal coincide con lógica calcularPago.&#10;[ ] Botón Play again: limpia apuestas y hace popBackStack() correctamente.&#10;[ ] Botón Exit: navega a &quot;menu&quot; con popUpTo(&quot;menu&quot;){inclusive=true} sin duplicados.&#10;[ ] Rotación: NO se repiten escrituras en Room (guardia lastPersistedResult evita duplicados).&#10;[ ] Accesibilidad: contentDescription presentes en ruleta y badge; contraste AA legible.&#10;[ ] CoinsDisplay permanece en esquina superior con padding.&#10;[ ] Responsividad: en pantallas grandes rueda ≈55% ancho y panel &gt;=280dp; en pequeñas no desborda.&#10;[ ] Colores del badge: verde para 0, rojo/negro según número; texto dorado 64sp.&#10;&#10;Resumen de cambios (PR):&#10;1. Refactor a estructura modular con componentes reutilizables (GirandoSection, BetSummaryCard, ResultadoSection, ResultBadge, ActionButtons).&#10;2. Añadido Crossfade (500ms) entre estados y BoxWithConstraints para responsividad.&#10;3. Implementado estilo glass cards con overlay radial y paleta oscuro+dorado.&#10;4. Mejora de accesibilidad: semantics y contentDescription clave.&#10;5. Cálculos y filtrados con remember/rememberSaveable para rendimiento y estado tras rotación.&#10;6. Escrituras a Room consolidadas en LaunchedEffect(resultado) con guardia de idempotencia.&#10;7. Botones Material3 nativos con estilos (sin dependencias ni drawables nuevos).&#10;8. Añadido checklist de pruebas y TODO(i18n) para internacionalización futura.&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>