<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/api/ruletaeuropea/Pantallas/PantallaIntro.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/api/ruletaeuropea/Pantallas/PantallaIntro.kt" />
              <option name="originalContent" value="package com.api.ruletaeuropea.pantallas&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.scaleIn&#10;import androidx.compose.animation.scaleOut&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.graphics.TransformOrigin&#10;import androidx.compose.ui.zIndex&#10;import androidx.navigation.NavController&#10;import com.api.ruletaeuropea.R&#10;import com.nativecoders.brand.NativeCodersGlitchLogo&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun PantallaIntro(navController: NavController) {&#10;    val visible = remember { mutableStateOf(false) }&#10;    // Estado separado para mostrar el logo de texto con un pequeño delay (stagger)&#10;    val showGlitch = remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        // animación de entrada&#10;        visible.value = true&#10;        // esperar a que termine la animación de entrada para luego mostrar el logo de texto&#10;        delay(1200) // coincide con el durationMillis del enter&#10;        showGlitch.value = true&#10;&#10;        // mantener la pantalla visible un poco más para que se aprecien los efectos&#10;        delay(4500)&#10;&#10;        // iniciar animación de salida&#10;        showGlitch.value = false&#10;        visible.value = false&#10;        // esperar a que termine la animación de salida antes de navegar&#10;        delay(700)&#10;&#10;        // navegar a login y eliminar la intro del backstack&#10;        navController.navigate(&quot;login&quot;) {&#10;            popUpTo(&quot;intro&quot;) { inclusive = true }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        AnimatedVisibility(&#10;            visible = visible.value,&#10;            enter = fadeIn(animationSpec = tween(durationMillis = 1200)) + scaleIn(initialScale = 0.85f, animationSpec = tween(1200)),&#10;            exit = fadeOut(animationSpec = tween(700)) + scaleOut(targetScale = 0.95f, animationSpec = tween(700))&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.wrapContentSize()) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.logo3d),&#10;                    contentDescription = &quot;Logo&quot;,&#10;                    modifier = Modifier&#10;                        .size(220.dp)&#10;                        .zIndex(0f) // aseguramos que el 3D esté por debajo&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(40.dp)) // aumentado para evitar solapamientos durante las animaciones&#10;&#10;                // Mostrar el logo de texto Native Coders con efecto glitch con un pequeño delay&#10;                AnimatedVisibility(&#10;                    visible = showGlitch.value,&#10;                    enter = fadeIn(animationSpec = tween(durationMillis = 900)) + scaleIn(initialScale = 0.92f, animationSpec = tween(900), transformOrigin = TransformOrigin(0.5f, 0f)),&#10;                    exit = fadeOut(animationSpec = tween(600)) + scaleOut(targetScale = 0.96f, animationSpec = tween(600), transformOrigin = TransformOrigin(0.5f, 0f))&#10;                ) {&#10;                    NativeCodersGlitchLogo(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.8f)&#10;                            .height(110.dp)&#10;                            .padding(top = 6.dp)&#10;                            .zIndex(1f), // forzamos que el glitch se dibuje por encima del logo3d&#10;                        enableBackground = false,&#10;                        intensity = 0.6f&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.api.ruletaeuropea.pantallas&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.scaleIn&#10;import androidx.compose.animation.scaleOut&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.graphics.TransformOrigin&#10;import androidx.compose.ui.zIndex&#10;import androidx.navigation.NavController&#10;import com.api.ruletaeuropea.R&#10;import com.nativecoders.brand.NativeCodersGlitchLogo&#10;import kotlinx.coroutines.delay&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;&#10;@Composable&#10;fun PantallaIntro(navController: NavController) {&#10;    val visible = remember { mutableStateOf(false) }&#10;    // Estado separado para mostrar el logo de texto con un pequeño delay (stagger)&#10;    val showGlitch = remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        // animación de entrada&#10;        visible.value = true&#10;        // esperar a que termine la animación de entrada para luego mostrar el logo de texto&#10;        delay(1200) // coincide con el durationMillis del enter&#10;        showGlitch.value = true&#10;&#10;        // mantener la pantalla visible un poco más para que se aprecien los efectos&#10;        delay(4500)&#10;&#10;        // iniciar animación de salida&#10;        showGlitch.value = false&#10;        visible.value = false&#10;        // esperar a que termine la animación de salida antes de navegar&#10;        delay(700)&#10;&#10;        // navegar a login y eliminar la intro del backstack&#10;        navController.navigate(&quot;login&quot;) {&#10;            popUpTo(&quot;intro&quot;) { inclusive = true }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        AnimatedVisibility(&#10;            visible = visible.value,&#10;            enter = fadeIn(animationSpec = tween(durationMillis = 1200)) + scaleIn(initialScale = 0.85f, animationSpec = tween(1200)),&#10;            exit = fadeOut(animationSpec = tween(700)) + scaleOut(targetScale = 0.95f, animationSpec = tween(700))&#10;        ) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.wrapContentSize()) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.logo3d),&#10;                    contentDescription = &quot;Logo&quot;,&#10;                    modifier = Modifier&#10;                        .size(220.dp)&#10;                        .zIndex(0f) // aseguramos que el 3D esté por debajo&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(40.dp)) // aumentado para evitar solapamientos durante las animaciones&#10;&#10;                // Mostrar el logo de texto Native Coders con efecto glitch con un pequeño delay&#10;                AnimatedVisibility(&#10;                    visible = showGlitch.value,&#10;                    enter = fadeIn(animationSpec = tween(durationMillis = 900)) + scaleIn(initialScale = 0.92f, animationSpec = tween(900), transformOrigin = TransformOrigin(0.5f, 0f)),&#10;                    exit = fadeOut(animationSpec = tween(600)) + scaleOut(targetScale = 0.96f, animationSpec = tween(600), transformOrigin = TransformOrigin(0.5f, 0f))&#10;                ) {&#10;                    BoxWithConstraints(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(110.dp)&#10;                            .padding(top = 6.dp)&#10;                            .zIndex(1f) // forzamos que el glitch se dibuje por encima del logo3d&#10;                    ) {&#10;                        val scale = when {&#10;                            maxWidth &lt; 300.dp -&gt; 0.70f&#10;                            maxWidth &lt; 340.dp -&gt; 0.78f&#10;                            maxWidth &lt; 380.dp -&gt; 0.85f&#10;                            else -&gt; 0.92f&#10;                        }&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .graphicsLayer { scaleX = scale; scaleY = scale }&#10;                        ) {&#10;                            NativeCodersGlitchLogo(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                enableBackground = false,&#10;                                intensity = 0.6f&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>